#!/usr/bin/env node
import*as b from"path";import l from"chalk";var f=class extends Error{constructor(t){super(t),this.name="BuildError"}},g=l.cyan("kumoya"),s={info:i=>{console.log(`${g} ${i}`)},error:i=>{i instanceof Error?(console.error(`${g} ${l.red("\u2716")} Build Error:`),console.error(`    ${i.message}`),i.stack&&console.error(l.gray(i.stack.split(`
    `).slice(1).map(t=>`    ${t.trim()}`).join(`
    `)))):(console.error(`${g} ${l.red("\u2716")} Build Error:`),console.error(`    ${i}`))},success:i=>{console.log(`${g} ${l.green("\u2713")} Done!`)},warn:i=>{console.log(`${g} ${l.yellow("\u26A0")} ${i}`)}};import{pathToFileURL as F}from"url";import*as p from"fs";import*as C from"path";var v=`export const kumoyaConfig = {
      entry: './src/index.ts',
      outputFolder: 'dist',
      bundle: true,
      outputType: true,
      minify: true,
      platform: 'node',
      packages: 'external',
    };
    `,D=new Set(["entry","outputFolder","outfile","bundle","outputType","format","platform","minify","packages","external","target","sourcemap","treeShaking","logLevel","extension"]);function w(i){let t={};t.platform="node",t.format="cjs";for(let o in i)D.has(o)?t[o]=i[o]:s.warn(`Unknown kumoya config option: "${o}", this option will be ignored`);return(Array.isArray(i.entry)?i.entry:[i.entry]).some(o=>o.endsWith(".js"))&&!i.platform&&!i.format&&s.warn("Building .js files without specified 'platform' or 'format'. Using default: platform='node', format='cjs'"),t}function x(i){let t=C.resolve(process.cwd(),i);if(!p.existsSync(t)){s.info("Config file not found, creating default configuration...");try{p.writeFileSync(t,v,"utf-8"),s.success(`Default config file created: ${i}`),process.exit(0)}catch(e){throw new Error(`Failed to create config file: ${e.message}`)}}}async function h(i="kumoya.config.mjs"){let t=b.resolve(process.cwd(),i);x(i);try{let r=await import(F(t).href);if(!r.kumoyaConfig)throw new f("kumoyaConfig is required in config file");if(!r.kumoyaConfig.entry)throw new f("entry is required in kumoyaConfig");return{kumoyaConfig:w(r.kumoyaConfig),esbuildConfig:r.esbuildConfig,rollupConfig:r.rollupConfig}}catch(e){throw e instanceof f?e:new f(`Failed to load config file: ${e.message}`)}}import*as $ from"esbuild";import{rollup as O}from"rollup";import E from"rollup-plugin-dts";import S from"@rollup/plugin-multi-entry";import{exec as B}from"child_process";import{promisify as T}from"util";import*as n from"path";import*as c from"fs";import{minimatch as j}from"minimatch";var d=T(B),u=class{config;esbuildConfig;rollupConfig;tsConfig;constructor(t){if(this.config={platform:"node",format:"cjs",...t.kumoyaConfig},this.config.format==="both"&&this.config.extension&&this.config.extension!=="js")throw new f("Cannot specify custom extension when format is 'both'");if(this.config.extension&&!["js","cjs","mjs"].includes(this.config.extension))throw new f("Extension must be one of: js, cjs, mjs");if(this.config.outputFolder&&this.config.outfile)throw new Error("outputFolder and outfile cannot be used together");if(this.config.outfile&&!this.config.bundle)throw new Error("outfile requires bundle to be true");try{let e=n.join(process.cwd(),"tsconfig.json");if(this.tsConfig=JSON.parse(c.readFileSync(e,"utf-8")),this.config.target)typeof this.config.target=="string"&&(this.config.target=this.config.target.toLowerCase());else{let r=this.tsConfig?.compilerOptions?.target?.toLowerCase();r&&(this.config.target=r,s.info(`Using target from tsconfig.json: ${this.config.target}`))}}catch{s.warn("Failed to read tsconfig.json, using default target settings"),this.tsConfig={}}!this.config.outputFolder&&!this.config.outfile&&(this.config.outputFolder=this.tsConfig?.compilerOptions?.outDir||"dist"),this.esbuildConfig=t.esbuildConfig,this.rollupConfig=t.rollupConfig}getOutputExtension(t){return this.config.format==="both"?t==="esm"?".mjs":".cjs":this.config.extension?`.${this.config.extension}`:".js"}async buildWithEsbuild(t,e="cjs"){let r;if(this.config.outfile)r=this.config.outfile,e=n.extname(this.config.outfile)==="mjs"?"esm":"cjs";else{let a=this.getOutputExtension(e);r=n.join(this.config.outputFolder,`${n.parse(t).name}${a}`)}if(this.config.packages&&this.config.external)throw new f("Cannot use both 'packages' and 'external' options");let o={entryPoints:[t],bundle:this.config.bundle,outfile:r,packages:this.config.packages||"external",platform:this.config.platform||"node",format:e,target:this.config.target||"es2015"};this.config.minify!==void 0&&(o.minify=this.config.minify),this.config.sourcemap!==void 0&&(o.sourcemap=this.config.sourcemap),this.config.treeShaking!==void 0&&(o.treeShaking=this.config.treeShaking),this.config.logLevel&&(o.logLevel=this.config.logLevel),this.config.external?.length&&(o.external=this.config.external),s.info(`${t} ==> ${r}`),await $.build({...o,...this.esbuildConfig})}getEntryDirs(){return(Array.isArray(this.config.entry)?this.config.entry:[this.config.entry]).reduce((e,r)=>{let o=n.dirname(r);return e[o]=e[o]||[],e[o].push(r),e},{})}isInTsConfig(t){let e=this.tsConfig?.include||[],r=this.tsConfig?.exclude||[];return e.some(o=>j(t,o))&&!r.some(o=>j(t,o))}async buildTypes(){let t=n.join(process.cwd(),".kumoyatmp"),e=this.getEntryDirs(),r=Object.keys(e);try{if(this.config.bundle){if(r.length===1&&(this.isInTsConfig(r[0])||this.tsConfig?.compilerOptions?.rootDir)){let a=this.tsConfig?.compilerOptions?.rootDir||r[0];await d(`tsc --declaration --emitDeclarationOnly --rootDir ${a} --outDir ${t}`)}else for(let a of r){let m=n.join(t,n.basename(a));await d(`tsc --declaration --emitDeclarationOnly --rootDir ${a} --outDir ${m} ${e[a].join(" ")}`)}let o=Array.isArray(this.config.entry)?this.config.entry:[this.config.entry];for(let a of o){let m=n.parse(a).name,k=this.config.outfile?n.dirname(this.config.outfile):this.config.outputFolder,y=n.join(k,`${m}.d.ts`);s.info(`${a} ==> ${y}`),await(await O({input:`${t}/**/*.d.ts`,plugins:[S(),E(),...this.rollupConfig?.plugins||[]]})).write({file:y,format:"es"})}c.existsSync(t)&&c.rmSync(t,{recursive:!0,force:!0})}else await d(`tsc --declaration --emitDeclarationOnly --outDir ${this.config.outputFolder}`)}catch(o){throw c.existsSync(t)&&c.rmSync(t,{recursive:!0,force:!0}),o}}async build(){let t=Array.isArray(this.config.entry)?this.config.entry:[this.config.entry],e=this.config.format==="both"?["esm","cjs"]:[this.config.format||"cjs"];for(let r of t)for(let o of e)await this.buildWithEsbuild(r,o);this.config.outputType&&await this.buildTypes()}};async function A(){try{let i=await h();s.info("Starting build process..."),await new u(i).build(),s.success("Done!")}catch(i){i instanceof f?s.error(i):s.error(i),process.exit(1)}}A();export{u as Builder,h as loadConfig};
    